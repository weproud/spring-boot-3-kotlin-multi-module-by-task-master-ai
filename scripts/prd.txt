# Spring Boot 3 Kotlin 애플리케이션 개발 PRD

# task 생성할 때 한국어로 작성

## 프로젝트 개요
이 프로젝트는 Spring Boot 3와 Kotlin을 사용하여 현대적인 웹 애플리케이션을 개발하는 것을 목표로 합니다. 
RESTful API를 제공하고, 데이터베이스와 연동하며, 보안 기능을 갖춘 애플리케이션을 구현합니다.

## 기술 스택
- Spring Boot 3.x
- Kotlin 1.8+
- Spring Data JPA
- Spring Security
- PostgreSQL/H2 데이터베이스
- Gradle 빌드 시스템
- JUnit 5 테스트 프레임워크
- Swagger/OpenAPI 문서화

## 기술적 요구사항

### 1. 아키텍처
- 클린 아키텍처 원칙 적용
- 계층 분리 (컨트롤러, 서비스, 레포지토리)
- 의존성 주입을 통한 결합도 낮추기

### 2. 데이터베이스
- JPA 엔티티 설계
- 관계 매핑 (일대다, 다대다 등)
- 트랜잭션 관리
- 마이그레이션 전략

### 3. API 설계
- RESTful API 원칙 준수
- 적절한 HTTP 메서드 및 상태 코드 사용
- API 버전 관리
- 에러 핸들링 및 응답 표준화

### 4. 보안
- Spring Security 구성
- CSRF 보호
- XSS 방지
- 입력 유효성 검사

### 5. 테스트
- 단위 테스트
- 통합 테스트
- 모킹 및 테스트 더블 활용
- 테스트 커버리지 목표: 80% 이상

### 6. 성능
- 캐싱 전략
- 비동기 처리
- 페이지네이션 구현
- N+1 문제 해결

### 7. 모니터링 및 로깅
- 애플리케이션 로깅 설정
- 성능 모니터링
- 에러 추적 및 알림

## 배포 요구사항
- Docker 컨테이너화
- CI/CD 파이프라인 구성
- 환경별 설정 관리 (개발, 테스트, 프로덕션)
- 데이터베이스 백업 및 복구 전략

## 프로젝트 일정
- 설계 및 아키텍처 구성: 2주
- 핵심 기능 개발: 8주
- 테스트 및 버그 수정: 2주
- 문서화 및 배포 준비: 1주

## 성공 기준
- 모든 핵심 기능이 구현되고 테스트됨
- 코드 품질 및 테스트 커버리지 목표 달성
- 보안 취약점 없음
- 성능 요구사항 충족


## 핵심 기능 요구사항

### 1. Gradle Multi Module 설계

- Gradle Multi Module 구조 만들기

```
tree -Ld 3 .
.
├── app
│   ├── app-api                # api
│   ├── app-admin-api          # admin-api
├── core                       # core
├── docs
├── domain
│   ├── common
│   └── rds                    # Entity, Repository
├── framework
│   ├── client                 # Http Client
│   │   ├── ai
│   │   ├── base               # WebClient 공통 설정
│   │   └── kakao
│   ├── provider
│   │   └── jwt                # Jwt Provider 
│   └── redis
└── http                       # xxx.http 파일
    ├── admin
    ├── teacher
    └── user
```

### 2. app-api 구현
- domain 단위로 패키지 구성
```
├── api
│   ├── chat
│   │   └── v1
│   │       ├── ChatController.kt
│   │       ├── ChatService.kt
│   │       └── dto
│   │           └── ChatResponse.kt
│   ├── user
│   │   └── v1
│   │       ├── dto
│   │       │   └── UserResponse.kt
│   │       ├── UserController.kt
│   │       └── UserService.kt
│   └── product 
│       └── v1
│           ├── ProductController.kt
│           └── ProductService.kt
```
- Security 설정(UserDetails, )
- AOP(ServletRequest logging)
- CORS 
- Audit
- Timezone: Asia/Seoul
- ApiException
1. 각 도메인별로 ApiException을 상속받아서 구현
2. EnumStatus 활용하지 말것
```
/**
 * Api 예외 클래스
 */
class ApiException(
    val errorCode: ErrorCode,
    override val message: String = errorCode.message,
    val data: Any? = null,
    cause: Throwable? = null
) : RuntimeException(message, cause) {
    
    /**
     * HTTP 상태 코드 반환
     */
    fun getStatusCode(): Int {
        return errorCode.status.value()
    }
}
```

- ObjectMapper 
```
object ObjectMapperFactory {
    fun objectMapper(): ObjectMapper =
        jacksonObjectMapper()
            .findAndRegisterModules()
            .registerKotlinModule()
            .configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false)
            .configure(SerializationFeature.WRITE_DURATIONS_AS_TIMESTAMPS, false)
            .configure(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS, false)
            .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
            .configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true)
            .registerModule(
                JavaTimeModule()
                    .addSerializer(ZonedDateTime::class.java, ZonedDateTimeSerializer())
                    .addDeserializer(ZonedDateTime::class.java, ZonedDateTimeDeserializer()),
            )

    private class ZonedDateTimeSerializer : StdSerializer<ZonedDateTime>(ZonedDateTime::class.java) {
        @Throws(IOException::class)
        override fun serialize(
            value: ZonedDateTime,
            generator: JsonGenerator,
            provider: SerializerProvider,
        ) {
            generator.writeString(
                value.truncatedTo(ChronoUnit.SECONDS).format(DateTimeFormatter.ISO_OFFSET_DATE_TIME),
            )
        }
    }

    private class ZonedDateTimeDeserializer : StdDeserializer<ZonedDateTime>(ZonedDateTime::class.java) {
        @Throws(IOException::class)
        override fun deserialize(
            parser: JsonParser,
            context: DeserializationContext,
        ): ZonedDateTime {
            return InstantDeserializer.ZONED_DATE_TIME.deserialize(parser, context)
                .withZoneSameInstant(ZoneId.of("Asia/Seoul"))
        }
    }
}
```

- ApiResponse: Response wrapping
```
data class BaseResponse<T>(
    val message: String = "ok",
    val data: T? = null,
) {
    companion object {
        fun <T> ok(data: T? = null): BaseResponse<T> = BaseResponse(data = data)
    }
}
```